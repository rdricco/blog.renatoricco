{"version":3,"sources":["webpack:///component---src-pages-sobre-jsx-b7ae8993c68704dd3f46.js","webpack:///./~/@nx-js/observer-util/dist/cjs.es5.js?b7f3","webpack:///./~/react-easy-state/dist/cjs.es5.js?bdb8","webpack:///./~/react-theme-switch/build/index.js?f5b8","webpack:///./src/data/rebassTheme.jsx?5580","webpack:///./src/data/themeStore.jsx?a9c4","webpack:///./src/pages/sobre.jsx"],"names":["webpackJsonp","24","module","exports","storeObservable","obj","connectionStore","set","Object","create","registerReactionForOperation","reaction","ref","target","key","type","ITERATION_KEY","reactionsForObj","get","reactionsForKey","Set","has","add","cleaners","push","getReactionsForOperation","reactionsForTarget","key$1","addReactionsForKey","iterationKey","Array","isArray","reactions","forEach","releaseReaction","releaseReactionKeyConnection","delete","this","runAsReaction","fn","context","args","unobserved","apply","runningReaction","undefined","registerRunningReactionForOperation","operation","debugOperation","queueReactionsForOperation","queueReaction","scheduler","debugger","isDebugging","hasRunningReaction","observe","options","IS_REACTION","arguments","lazy","unobserve","shouldInstrument","constructor","isBuiltIn","name","globalObj","handlers","getHandlers","receiver","result","Reflect","observableResult","rawToProxy","descriptor","getOwnPropertyDescriptor","writable","configurable","observable","ownKeys","value","proxyToRaw","hadKey","hasOwnProperty$1","call","oldValue","console","error","deleteProperty","createObservable","baseHandlers","Proxy","isObservable","raw","defineProperty","WeakMap","Symbol","getPrototypeOf","hasOwnProperty","prototype","instrumentations","proto","clear","hadItems","size","oldTarget","Map","keys","values","entries","iterator","collectionHandlers","Function","WeakSet","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","13","__webpack_require__","view","Comp","rawDevtool","devtool","isStatelessComp","isReactComponent","BaseComp","react","Component","assign","ReactiveHOC","props","this$1","render","observerUtil","setState","__proto__","shouldComponentUpdate","nextProps","nextState","state","renderType","nextKeys","length","some","oldProps","componentWillUnmount","displayName","contextTypes","childContextTypes","propTypes","defaultProps","store","137","_interopRequireDefault","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","enumerable","setPrototypeOf","_createClass","defineProperties","i","protoProps","staticProps","_react","_react2","ThemeSwitch","_Component","_this","localStorage","css","preserveRasters","active","supported","toggle","bind","property","prop","el","document","createElement","mStyle","style","cssText","invertSupported","getItem","setItem","aria-pressed","onClick","aria-hidden","media","trim","26","breakpoints","space","fontSizes","weights","colors","purplegatsby","black","blacktotal","lightGrey","grey","gold","aqua","blue","navy","teal","tealdarker","green","olive","lime","yellow","orange","red","fuchsia","purple","maroon","white","silver","gray","primary","secondary","secondaryLight","secondaryLightest","secondaryDark","light","offLight","shadows","basic","bg","radius","font","headerFont","monospace","27","darkMode","lightMode","themeVariables","themeMode","_reactEasyState","_rebassTheme","primaryColor","secondaryColor","additionalColor","tagBadgeBgColor","fontColor","fontAdditionalColor","bodyFont","AdditionalFont","229","_reactHelmet","_rebass","_animateComponents","_reactThemeSwitch","AboutPage","Container","pt","pb","FadeIn"],"mappings":"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","file":"component---src-pages-sobre-jsx-b7ae8993c68704dd3f46.js","sourcesContent":["webpackJsonp([120173200258306],{\n\n/***/ 24:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tvar connectionStore = new WeakMap();\n\tvar ITERATION_KEY = Symbol('iteration key');\n\t\n\tfunction storeObservable(obj) {\n\t  // this will be used to save (obj.key -> reaction) connections later\n\t  connectionStore.set(obj, Object.create(null));\n\t}\n\t\n\tfunction registerReactionForOperation(reaction, ref) {\n\t  var target = ref.target;\n\t  var key = ref.key;\n\t  var type = ref.type;\n\t\n\t  if (type === 'iterate') {\n\t    key = ITERATION_KEY;\n\t  }\n\t\n\t  var reactionsForObj = connectionStore.get(target);\n\t  var reactionsForKey = reactionsForObj[key];\n\t  if (!reactionsForKey) {\n\t    reactionsForObj[key] = reactionsForKey = new Set();\n\t  }\n\t  // save the fact that the key is used by the reaction during its current run\n\t  if (!reactionsForKey.has(reaction)) {\n\t    reactionsForKey.add(reaction);\n\t    reaction.cleaners.push(reactionsForKey);\n\t  }\n\t}\n\t\n\tfunction getReactionsForOperation(ref) {\n\t  var target = ref.target;\n\t  var key = ref.key;\n\t  var type = ref.type;\n\t\n\t  var reactionsForTarget = connectionStore.get(target);\n\t  var reactionsForKey = new Set();\n\t\n\t  if (type === 'clear') {\n\t    for (var key$1 in reactionsForTarget) {\n\t      addReactionsForKey(reactionsForKey, reactionsForTarget, key$1);\n\t    }\n\t  } else {\n\t    addReactionsForKey(reactionsForKey, reactionsForTarget, key);\n\t  }\n\t\n\t  if (type === 'add' || type === 'delete' || type === 'clear') {\n\t    var iterationKey = Array.isArray(target) ? 'length' : ITERATION_KEY;\n\t    addReactionsForKey(reactionsForKey, reactionsForTarget, iterationKey);\n\t  }\n\t\n\t  return reactionsForKey;\n\t}\n\t\n\tfunction addReactionsForKey(reactionsForKey, reactionsForTarget, key) {\n\t  var reactions = reactionsForTarget[key];\n\t  reactions && reactions.forEach(reactionsForKey.add, reactionsForKey);\n\t}\n\t\n\tfunction releaseReaction(reaction) {\n\t  if (reaction.cleaners) {\n\t    reaction.cleaners.forEach(releaseReactionKeyConnection, reaction);\n\t  }\n\t  reaction.cleaners = [];\n\t}\n\t\n\tfunction releaseReactionKeyConnection(reactionsForKey) {\n\t  reactionsForKey.delete(this);\n\t}\n\t\n\tvar runningReaction;\n\tvar isDebugging = false;\n\t\n\tfunction runAsReaction(reaction, fn, context, args) {\n\t  // do not build reactive relations, if the reaction is unobserved\n\t  if (reaction.unobserved) {\n\t    return fn.apply(context, args);\n\t  }\n\t\n\t  // release the (obj -> key -> reactions) connections\n\t  // and reset the cleaner connections\n\t  releaseReaction(reaction);\n\t\n\t  try {\n\t    // set the reaction as the currently running one\n\t    // this is required so that we can create (observable.prop -> reaction) pairs in the get trap\n\t    runningReaction = reaction;\n\t    return fn.apply(context, args);\n\t  } finally {\n\t    // always remove the currently running flag from the reaction when it stops execution\n\t    runningReaction = undefined;\n\t  }\n\t}\n\t\n\t// register the currently running reaction to be queued again on obj.key mutations\n\tfunction registerRunningReactionForOperation(operation) {\n\t  if (runningReaction) {\n\t    debugOperation(runningReaction, operation);\n\t    registerReactionForOperation(runningReaction, operation);\n\t  }\n\t}\n\t\n\tfunction queueReactionsForOperation(operation) {\n\t  // iterate and queue every reaction, which is triggered by obj.key mutation\n\t  getReactionsForOperation(operation).forEach(queueReaction, operation);\n\t}\n\t\n\tfunction queueReaction(reaction) {\n\t  debugOperation(reaction, this);\n\t  // queue the reaction for later execution or run it immediately\n\t  if (typeof reaction.scheduler === 'function') {\n\t    reaction.scheduler(reaction);\n\t  } else if (typeof reaction.scheduler === 'object') {\n\t    reaction.scheduler.add(reaction);\n\t  } else {\n\t    reaction();\n\t  }\n\t}\n\t\n\tfunction debugOperation(reaction, operation) {\n\t  if (reaction.debugger && !isDebugging) {\n\t    try {\n\t      isDebugging = true;\n\t      reaction.debugger(operation);\n\t    } finally {\n\t      isDebugging = false;\n\t    }\n\t  }\n\t}\n\t\n\tfunction hasRunningReaction() {\n\t  return runningReaction !== undefined;\n\t}\n\t\n\tvar IS_REACTION = Symbol('is reaction');\n\t\n\tfunction observe(fn, options) {\n\t  if ( options === void 0 ) options = {};\n\t\n\t  // wrap the passed function in a reaction, if it is not already one\n\t  var reaction = fn[IS_REACTION] ? fn : function reaction() {\n\t    return runAsReaction(reaction, fn, this, arguments);\n\t  };\n\t  // save the scheduler and debugger on the reaction\n\t  reaction.scheduler = options.scheduler;\n\t  reaction.debugger = options.debugger;\n\t  // save the fact that this is a reaction\n\t  reaction[IS_REACTION] = true;\n\t  // run the reaction once if it is not a lazy one\n\t  if (!options.lazy) {\n\t    reaction();\n\t  }\n\t  return reaction;\n\t}\n\t\n\tfunction unobserve(reaction) {\n\t  // do nothing, if the reaction is already unobserved\n\t  if (!reaction.unobserved) {\n\t    // indicate that the reaction should not be triggered any more\n\t    reaction.unobserved = true;\n\t    // release (obj -> key -> reaction) connections\n\t    releaseReaction(reaction);\n\t  }\n\t  // unschedule the reaction, if it is scheduled\n\t  if (typeof reaction.scheduler === 'object') {\n\t    reaction.scheduler.delete(reaction);\n\t  }\n\t}\n\t\n\tvar proxyToRaw = new WeakMap();\n\tvar rawToProxy = new WeakMap();\n\t\n\tvar getPrototypeOf = Object.getPrototypeOf;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\tvar instrumentations = {\n\t  has: function has(key) {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    registerRunningReactionForOperation({ target: target, key: key, type: 'has' });\n\t    return proto.has.apply(target, arguments);\n\t  },\n\t  get: function get(key) {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    registerRunningReactionForOperation({ target: target, key: key, type: 'get' });\n\t    return proto.get.apply(target, arguments);\n\t  },\n\t  add: function add(key) {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    var hadKey = proto.has.call(target, key);\n\t    // forward the operation before queueing reactions\n\t    var result = proto.add.apply(target, arguments);\n\t    if (!hadKey) {\n\t      queueReactionsForOperation({ target: target, key: key, value: key, type: 'add' });\n\t    }\n\t    return result;\n\t  },\n\t  set: function set(key, value) {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    var hadKey = proto.has.call(target, key);\n\t    var oldValue = proto.get.call(target, key);\n\t    // forward the operation before queueing reactions\n\t    var result = proto.set.apply(target, arguments);\n\t    if (!hadKey) {\n\t      queueReactionsForOperation({ target: target, key: key, value: value, type: 'add' });\n\t    } else if (value !== oldValue) {\n\t      queueReactionsForOperation({ target: target, key: key, value: value, oldValue: oldValue, type: 'set' });\n\t    }\n\t    return result;\n\t  },\n\t  delete: function delete$1(key) {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    var hadKey = proto.has.call(target, key);\n\t    var oldValue = proto.get ? proto.get.call(target, key) : undefined;\n\t    // forward the operation before queueing reactions\n\t    var result = proto.delete.apply(target, arguments);\n\t    if (hadKey) {\n\t      queueReactionsForOperation({ target: target, key: key, oldValue: oldValue, type: 'delete' });\n\t    }\n\t    return result;\n\t  },\n\t  clear: function clear() {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    var hadItems = target.size !== 0;\n\t    var oldTarget = target instanceof Map ? new Map(target) : new Set(target);\n\t    // forward the operation before queueing reactions\n\t    var result = proto.clear.apply(target, arguments);\n\t    if (hadItems) {\n\t      queueReactionsForOperation({ target: target, oldTarget: oldTarget, type: 'clear' });\n\t    }\n\t    return result;\n\t  },\n\t  forEach: function forEach() {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n\t    return proto.forEach.apply(target, arguments);\n\t  },\n\t  keys: function keys() {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n\t    return proto.keys.apply(target, arguments);\n\t  },\n\t  values: function values() {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n\t    return proto.values.apply(target, arguments);\n\t  },\n\t  entries: function entries() {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n\t    return proto.entries.apply(target, arguments);\n\t  },\n\t  get size() {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n\t    return Reflect.get(proto, 'size', target);\n\t  }\n\t};\n\tinstrumentations[Symbol.iterator] = function () {\n\t    var target = proxyToRaw.get(this);\n\t    var proto = getPrototypeOf(this);\n\t    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n\t    return proto[Symbol.iterator].apply(target, arguments);\n\t  };\n\t\n\tvar collectionHandlers = {\n\t  get: function get(target, key, receiver) {\n\t    // instrument methods and property accessors to be reactive\n\t    target = hasOwnProperty.call(instrumentations, key) ? instrumentations : target;\n\t    return Reflect.get(target, key, receiver);\n\t  }\n\t};\n\t\n\t// eslint-disable-next-line\n\tvar globalObj = Function(\"return this\")();\n\t\n\t// built-in object can not be wrapped by Proxies\n\t// their methods expect the object instance as the 'this' instead of the Proxy wrapper\n\t// complex objects are wrapped with a Proxy of instrumented methods\n\t// which switch the proxy to the raw object and to add reactive wiring\n\tvar handlers = new Map([[Map, collectionHandlers], [Set, collectionHandlers], [WeakMap, collectionHandlers], [WeakSet, collectionHandlers], [Object, false], [Array, false], [Int8Array, false], [Uint8Array, false], [Uint8ClampedArray, false], [Int16Array, false], [Uint16Array, false], [Int32Array, false], [Uint32Array, false], [Float32Array, false], [Float64Array, false]]);\n\t\n\tfunction shouldInstrument(ref) {\n\t  var constructor = ref.constructor;\n\t\n\t  var isBuiltIn = typeof constructor === 'function' && constructor.name in globalObj && globalObj[constructor.name] === constructor;\n\t  return !isBuiltIn || handlers.has(constructor);\n\t}\n\t\n\tfunction getHandlers(obj) {\n\t  return handlers.get(obj.constructor);\n\t}\n\t\n\tvar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\t\n\t// intercept get operations on observables to know which reaction uses their properties\n\tfunction get(target, key, receiver) {\n\t  var result = Reflect.get(target, key, receiver);\n\t  // do not register (observable.prop -> reaction) pairs for these cases\n\t  if (typeof key === 'symbol' || typeof result === 'function') {\n\t    return result;\n\t  }\n\t  // register and save (observable.prop -> runningReaction)\n\t  registerRunningReactionForOperation({ target: target, key: key, receiver: receiver, type: 'get' });\n\t  // if we are inside a reaction and observable.prop is an object wrap it in an observable too\n\t  // this is needed to intercept property access on that object too (dynamic observable tree)\n\t  var observableResult = rawToProxy.get(result);\n\t  if (hasRunningReaction() && typeof result === 'object' && result !== null) {\n\t    if (observableResult) {\n\t      return observableResult;\n\t    }\n\t    // do not violate the none-configurable none-writable prop get handler invariant\n\t    // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError\n\t    var descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n\t    if (!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) {\n\t      return observable(result);\n\t    }\n\t  }\n\t  // otherwise return the observable wrapper if it is already created and cached or the raw object\n\t  return observableResult || result;\n\t}\n\t\n\tfunction has(target, key) {\n\t  var result = Reflect.has(target, key);\n\t  // do not register (observable.prop -> reaction) pairs for these cases\n\t  if (typeof key === 'symbol') {\n\t    return result;\n\t  }\n\t  // register and save (observable.prop -> runningReaction)\n\t  registerRunningReactionForOperation({ target: target, key: key, type: 'has' });\n\t  return result;\n\t}\n\t\n\tfunction ownKeys(target) {\n\t  registerRunningReactionForOperation({ target: target, type: 'iterate' });\n\t  return Reflect.ownKeys(target);\n\t}\n\t\n\t// intercept set operations on observables to know when to trigger reactions\n\tfunction set(target, key, value, receiver) {\n\t  // make sure to do not pollute the raw object with observables\n\t  if (typeof value === 'object' && value !== null) {\n\t    value = proxyToRaw.get(value) || value;\n\t  }\n\t  // save if the object had a descriptor for this key\n\t  var hadKey = hasOwnProperty$1.call(target, key);\n\t  // save if the value changed because of this set operation\n\t  var oldValue = target[key];\n\t  // execute the set operation before running any reaction\n\t  var result = Reflect.set(target, key, value, receiver);\n\t  // emit a warning and do not queue anything when another reaction is queued\n\t  // from an already running reaction\n\t  if (hasRunningReaction()) {\n\t    console.error((\"Mutating observables in reactions is forbidden. You set \" + key + \" to \" + value + \".\"));\n\t    return result;\n\t  }\n\t  // do not queue reactions if it is a symbol keyed property\n\t  // or the target of the operation is not the raw receiver\n\t  // (possible because of prototypal inheritance)\n\t  if (typeof key === 'symbol' || target !== proxyToRaw.get(receiver)) {\n\t    return result;\n\t  }\n\t\n\t  // queue a reaction if it's a new property or its value changed\n\t  if (!hadKey) {\n\t    queueReactionsForOperation({ target: target, key: key, value: value, receiver: receiver, type: 'add' });\n\t  } else if (value !== oldValue) {\n\t    queueReactionsForOperation({\n\t      target: target,\n\t      key: key,\n\t      value: value,\n\t      oldValue: oldValue,\n\t      receiver: receiver,\n\t      type: 'set'\n\t    });\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction deleteProperty(target, key) {\n\t  // save if the object had the key\n\t  var hadKey = hasOwnProperty$1.call(target, key);\n\t  var oldValue = target[key];\n\t  // execute the delete operation before running any reaction\n\t  var result = Reflect.deleteProperty(target, key);\n\t  // only queue reactions for non symbol keyed property delete which resulted in an actual change\n\t  if (typeof key !== 'symbol' && hadKey) {\n\t    queueReactionsForOperation({ target: target, key: key, oldValue: oldValue, type: 'delete' });\n\t  }\n\t  return result;\n\t}\n\t\n\tvar baseHandlers = { get: get, has: has, ownKeys: ownKeys, set: set, deleteProperty: deleteProperty };\n\t\n\tfunction observable(obj) {\n\t  if ( obj === void 0 ) obj = {};\n\t\n\t  // if it is already an observable or it should not be wrapped, return it\n\t  if (proxyToRaw.has(obj) || !shouldInstrument(obj)) {\n\t    return obj;\n\t  }\n\t  // if it already has a cached observable wrapper, return it\n\t  // otherwise create a new observable\n\t  return rawToProxy.get(obj) || createObservable(obj);\n\t}\n\t\n\tfunction createObservable(obj) {\n\t  // if it is a complex built-in object or a normal object, wrap it\n\t  var handlers = getHandlers(obj) || baseHandlers;\n\t  var observable = new Proxy(obj, handlers);\n\t  // save these to switch between the raw object and the wrapped object with ease later\n\t  rawToProxy.set(obj, observable);\n\t  proxyToRaw.set(observable, obj);\n\t  // init basic data structures to save and cleanup later (observable.prop -> reaction) connections\n\t  storeObservable(obj);\n\t  return observable;\n\t}\n\t\n\tfunction isObservable(obj) {\n\t  return proxyToRaw.has(obj);\n\t}\n\t\n\tfunction raw(obj) {\n\t  return proxyToRaw.get(obj) || obj;\n\t}\n\t\n\texports.observe = observe;\n\texports.unobserve = unobserve;\n\texports.observable = observable;\n\texports.isObservable = isObservable;\n\texports.raw = raw;\n\n\n/***/ }),\n\n/***/ 13:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tvar react = __webpack_require__(2);\n\tvar observerUtil = __webpack_require__(24);\n\t\n\tfunction view(Comp, ref) {\n\t  if ( ref === void 0 ) ref = {};\n\t  var rawDevtool = ref.devtool;\n\t\n\t  var isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent);\n\t  var BaseComp = isStatelessComp ? react.Component : Comp;\n\t\n\t  var devtool = rawDevtool ? function (operation) { return rawDevtool(Object.assign({ Component: Comp }, operation)); } : undefined;\n\t\n\t  // return a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount\n\t  // it decides when to run the new reactive methods and when to proxy to the original methods\n\t  var ReactiveHOC = (function (BaseComp) {\n\t    function ReactiveHOC(props, context) {\n\t      var this$1 = this;\n\t\n\t      BaseComp.call(this, props, context);\n\t\n\t      // create a reactive render for the component\n\t      // run a dummy setState to schedule a new reactive render, avoid forceUpdate\n\t      this.render = observerUtil.observe(this.render, {\n\t        scheduler: function () { return this$1.setState({}); },\n\t        debugger: devtool,\n\t        lazy: true\n\t      });\n\t    }\n\t\n\t    if ( BaseComp ) ReactiveHOC.__proto__ = BaseComp;\n\t    ReactiveHOC.prototype = Object.create( BaseComp && BaseComp.prototype );\n\t    ReactiveHOC.prototype.constructor = ReactiveHOC;\n\t\n\t    ReactiveHOC.prototype.render = function render () {\n\t      return isStatelessComp ? Comp(this.props, this.context) : BaseComp.prototype.render.call(this);\n\t    };\n\t\n\t    // react should trigger updates on prop changes, while easyState handles store changes\n\t    ReactiveHOC.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {\n\t      var ref = this;\n\t      var props = ref.props;\n\t      var state = ref.state;\n\t\n\t      // respect the case when user prohibits updates\n\t      if (BaseComp.prototype.shouldComponentUpdate && !BaseComp.prototype.shouldComponentUpdate.call(this, nextProps, nextState)) {\n\t        devtool && devtool({ type: 'render', renderType: 'blocked' });\n\t        return false;\n\t      }\n\t\n\t      // return true if it is a reactive render or state changes\n\t      if (state !== nextState) {\n\t        devtool && devtool({ type: 'render', renderType: 'reactive' });\n\t        return true;\n\t      }\n\t\n\t      // the component should update if any of its props shallowly changed value\n\t      var keys = Object.keys(props);\n\t      var nextKeys = Object.keys(nextProps);\n\t      if (nextKeys.length !== keys.length || nextKeys.some(function (key) { return props[key] !== nextProps[key]; })) {\n\t        devtool && devtool({\n\t          type: 'render',\n\t          renderType: 'normal',\n\t          props: nextProps,\n\t          oldProps: props\n\t        });\n\t        return true;\n\t      }\n\t      return false;\n\t    };\n\t\n\t    ReactiveHOC.prototype.componentWillUnmount = function componentWillUnmount () {\n\t      // call user defined componentWillUnmount\n\t      if (BaseComp.prototype.componentWillUnmount) {\n\t        BaseComp.prototype.componentWillUnmount.call(this);\n\t      }\n\t      // clean up memory used by Easy State\n\t      observerUtil.unobserve(this.render);\n\t    };\n\t\n\t    return ReactiveHOC;\n\t  }(BaseComp));\n\t\n\t  ReactiveHOC.displayName = Comp.displayName || Comp.name;\n\t  // these are inherited by class components,\n\t  // but have to be copied for function components\n\t  if (isStatelessComp) {\n\t    ReactiveHOC.contextTypes = Comp.contextTypes;\n\t    ReactiveHOC.childContextTypes = Comp.childContextTypes;\n\t    ReactiveHOC.propTypes = Comp.propTypes;\n\t    ReactiveHOC.defaultProps = Comp.defaultProps;\n\t  }\n\t\n\t  return ReactiveHOC;\n\t}\n\t\n\texports.store = observerUtil.observable;\n\texports.view = view;\n\n\n/***/ }),\n\n/***/ 137:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar ThemeSwitch = function (_Component) {\n\t  _inherits(ThemeSwitch, _Component);\n\t\n\t  function ThemeSwitch(props) {\n\t    _classCallCheck(this, ThemeSwitch);\n\t\n\t    var _this = _possibleConstructorReturn(this, (ThemeSwitch.__proto__ || Object.getPrototypeOf(ThemeSwitch)).call(this, props));\n\t\n\t    _this.store = typeof localStorage === 'undefined' ? null : localStorage;\n\t\n\t    _this.css = '\\n      html { filter: invert(100%); background: #fefefe; }\\n      * { background-color: inherit }\\n    ';\n\t\n\t    if (_this.props.preserveRasters) {\n\t      _this.css += 'img:not([src*=\".svg\"]), video, [style*=\"url(\"] { filter: invert(100%) }';\n\t    }\n\t\n\t    _this.state = {\n\t      active: false,\n\t      supported: true\n\t    };\n\t\n\t    _this.toggle = _this.toggle.bind(_this);\n\t    return _this;\n\t  }\n\t\n\t  _createClass(ThemeSwitch, [{\n\t    key: 'invertSupported',\n\t    value: function invertSupported(property, value) {\n\t      var prop = property + ':',\n\t          el = document.createElement('test'),\n\t          mStyle = el.style;\n\t      el.style.cssText = prop + value;\n\t      return mStyle[property];\n\t    }\n\t  }, {\n\t    key: 'toggle',\n\t    value: function toggle() {\n\t      this.setState({\n\t        active: !this.state.active\n\t      });\n\t    }\n\t  }, {\n\t    key: 'componentDidMount',\n\t    value: function componentDidMount() {\n\t      if (this.store) {\n\t        this.setState({\n\t          supported: this.invertSupported('filter', 'invert(100%)'),\n\t          active: this.store.getItem('ThemeSwitch') || false\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: 'componentDidUpdate',\n\t    value: function componentDidUpdate() {\n\t      if (this.store) {\n\t        this.store.setItem('ThemeSwitch', this.state.active);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render() {\n\t      if (!this.state.supported) {\n\t        return null;\n\t      }\n\t\n\t      return _react2.default.createElement(\n\t        'div',\n\t        null,\n\t        _react2.default.createElement(\n\t          'button',\n\t          { 'aria-pressed': this.state.active, onClick: this.toggle },\n\t          'inverted theme: ',\n\t          _react2.default.createElement(\n\t            'span',\n\t            { 'aria-hidden': 'true' },\n\t            this.state.active ? 'on' : 'off'\n\t          )\n\t        ),\n\t        _react2.default.createElement(\n\t          'style',\n\t          { media: this.state.active ? 'screen' : 'none' },\n\t          this.state.active ? this.css.trim() : this.css\n\t        )\n\t      );\n\t    }\n\t  }]);\n\t\n\t  return ThemeSwitch;\n\t}(_react.Component);\n\t\n\tThemeSwitch.defaultProps = { preserveRasters: 'true' };\n\t\n\texports.default = ThemeSwitch;\n\n/***/ }),\n\n/***/ 26:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t// Default values\n\texports.default = {\n\t  breakpoints: [32, 48, 64, 80],\n\t  space: [0, 4, 8, 16, 32, 64, 128],\n\t  fontSizes: [12, 14, 15, 20, 24, 32, 48, 64, 72, 96],\n\t  weights: [400, 700],\n\t  colors: {\n\t    purplegatsby: '#744c9e',\n\t    black: \"#303030\",\n\t    blacktotal: '#000',\n\t    lightGrey: \"#E9E7E7\",\n\t    grey: \"#bbb\",\n\t    gold: \"#cdc1a4\",\n\t    aqua: '#7FDBFF',\n\t    blue: '#0074D9',\n\t    navy: '#001F3F',\n\t    teal: '#39CCCC',\n\t    tealdarker: '#2ca9a9',\n\t    green: '#2ECC40',\n\t    olive: '#3D9970',\n\t    lime: '#01FF70',\n\t    yellow: '#FFDC00',\n\t    orange: '#FF851B',\n\t    red: '#FF4136',\n\t    fuchsia: '#F012BE',\n\t    purple: '#B10DC9',\n\t    maroon: '#85144B',\n\t    white: '#FFFFFF',\n\t    silver: '#DDDDDD',\n\t    gray: '#AAAAAA',\n\t    primary: \"#F46965\",\n\t    secondary: \"#cdc1a4\",\n\t    secondaryLight: \"#e4ddcd\",\n\t    secondaryLightest: \"#f5f2ed\",\n\t    secondaryDark: \"#d1ba85\",\n\t    light: \"#fff\",\n\t    offLight: \"#E2E6EA\"\n\t  },\n\t  shadows: {\n\t    basic: \"0 1px 3px rgba(50,50,93,.06)\"\n\t  },\n\t  bg: \"#aea\",\n\t  radius: 4,\n\t  font: '\"Roboto\", sans-serif',\n\t  headerFont: '\"Anonymous Pro\",\"Poppins\",\"Helvetica Neue\", \"Segoe UI\",\"Helvetica\", \"Arial\", \"sans-serif\"',\n\t  monospace: '\"SF Mono\", \"Roboto Mono\", Menlo, monospace'\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }),\n\n/***/ 27:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.darkMode = exports.lightMode = exports.themeVariables = exports.themeMode = undefined;\n\t\n\tvar _reactEasyState = __webpack_require__(13);\n\t\n\tvar _rebassTheme = __webpack_require__(26);\n\t\n\tvar _rebassTheme2 = _interopRequireDefault(_rebassTheme);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar themeMode = exports.themeMode = (0, _reactEasyState.store)({\n\t  darkMode: true\n\t});\n\t\n\tvar themeVariables = exports.themeVariables = (0, _reactEasyState.store)({\n\t  primaryColor: 'white',\n\t  secondaryColor: 'lightGrey',\n\t  additionalColor: 'tealdarker',\n\t  tagBadgeBgColor: 'tealdarker',\n\t  fontColor: 'black',\n\t  fontAdditionalColor: 'tealdarker',\n\t  headerFont: '\"Poppins\",\"Helvetica Neue\", \"Segoe UI\",\"Helvetica\", \"Arial\", \"sans-serif\"',\n\t  bodyFont: '\"Roboto\", sans-serif',\n\t  AdditionalFont: '\"SF Mono\", \"Roboto Mono\", Menlo, monospace'\n\t});\n\t\n\tvar lightMode = exports.lightMode = (0, _reactEasyState.store)({\n\t  primaryColor: 'black',\n\t  secondaryColor: 'white',\n\t  additionalColor: 'teal',\n\t  fontColor: 'black',\n\t  fontAdditionalColor: 'green'\n\t});\n\t\n\tvar darkMode = exports.darkMode = (0, _reactEasyState.store)({\n\t  primaryColor: 'black',\n\t  secondaryColor: 'white',\n\t  additionalColor: 'teal',\n\t  fontColor: 'black',\n\t  fontAdditionalColor: 'green'\n\t});\n\n/***/ }),\n\n/***/ 229:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(2);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _reactHelmet = __webpack_require__(48);\n\t\n\tvar _reactHelmet2 = _interopRequireDefault(_reactHelmet);\n\t\n\tvar _rebass = __webpack_require__(5);\n\t\n\tvar _animateComponents = __webpack_require__(35);\n\t\n\tvar _themeStore = __webpack_require__(27);\n\t\n\tvar _reactEasyState = __webpack_require__(13);\n\t\n\tvar _reactThemeSwitch = __webpack_require__(137);\n\t\n\tvar _reactThemeSwitch2 = _interopRequireDefault(_reactThemeSwitch);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar AboutPage = function (_Component) {\n\t  _inherits(AboutPage, _Component);\n\t\n\t  function AboutPage() {\n\t    _classCallCheck(this, AboutPage);\n\t\n\t    return _possibleConstructorReturn(this, _Component.apply(this, arguments));\n\t  }\n\t\n\t  AboutPage.prototype.render = function render(view) {\n\t    return _react2.default.createElement(\n\t      _rebass.Container,\n\t      { pt: 4, pb: 6 },\n\t      _react2.default.createElement(_animateComponents.FadeIn, null)\n\t    );\n\t  };\n\t\n\t  return AboutPage;\n\t}(_react.Component);\n\t\n\texports.default = AboutPage;\n\tmodule.exports = exports['default'];\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-sobre-jsx-b7ae8993c68704dd3f46.js","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar connectionStore = new WeakMap();\nvar ITERATION_KEY = Symbol('iteration key');\n\nfunction storeObservable(obj) {\n  // this will be used to save (obj.key -> reaction) connections later\n  connectionStore.set(obj, Object.create(null));\n}\n\nfunction registerReactionForOperation(reaction, ref) {\n  var target = ref.target;\n  var key = ref.key;\n  var type = ref.type;\n\n  if (type === 'iterate') {\n    key = ITERATION_KEY;\n  }\n\n  var reactionsForObj = connectionStore.get(target);\n  var reactionsForKey = reactionsForObj[key];\n  if (!reactionsForKey) {\n    reactionsForObj[key] = reactionsForKey = new Set();\n  }\n  // save the fact that the key is used by the reaction during its current run\n  if (!reactionsForKey.has(reaction)) {\n    reactionsForKey.add(reaction);\n    reaction.cleaners.push(reactionsForKey);\n  }\n}\n\nfunction getReactionsForOperation(ref) {\n  var target = ref.target;\n  var key = ref.key;\n  var type = ref.type;\n\n  var reactionsForTarget = connectionStore.get(target);\n  var reactionsForKey = new Set();\n\n  if (type === 'clear') {\n    for (var key$1 in reactionsForTarget) {\n      addReactionsForKey(reactionsForKey, reactionsForTarget, key$1);\n    }\n  } else {\n    addReactionsForKey(reactionsForKey, reactionsForTarget, key);\n  }\n\n  if (type === 'add' || type === 'delete' || type === 'clear') {\n    var iterationKey = Array.isArray(target) ? 'length' : ITERATION_KEY;\n    addReactionsForKey(reactionsForKey, reactionsForTarget, iterationKey);\n  }\n\n  return reactionsForKey;\n}\n\nfunction addReactionsForKey(reactionsForKey, reactionsForTarget, key) {\n  var reactions = reactionsForTarget[key];\n  reactions && reactions.forEach(reactionsForKey.add, reactionsForKey);\n}\n\nfunction releaseReaction(reaction) {\n  if (reaction.cleaners) {\n    reaction.cleaners.forEach(releaseReactionKeyConnection, reaction);\n  }\n  reaction.cleaners = [];\n}\n\nfunction releaseReactionKeyConnection(reactionsForKey) {\n  reactionsForKey.delete(this);\n}\n\nvar runningReaction;\nvar isDebugging = false;\n\nfunction runAsReaction(reaction, fn, context, args) {\n  // do not build reactive relations, if the reaction is unobserved\n  if (reaction.unobserved) {\n    return fn.apply(context, args);\n  }\n\n  // release the (obj -> key -> reactions) connections\n  // and reset the cleaner connections\n  releaseReaction(reaction);\n\n  try {\n    // set the reaction as the currently running one\n    // this is required so that we can create (observable.prop -> reaction) pairs in the get trap\n    runningReaction = reaction;\n    return fn.apply(context, args);\n  } finally {\n    // always remove the currently running flag from the reaction when it stops execution\n    runningReaction = undefined;\n  }\n}\n\n// register the currently running reaction to be queued again on obj.key mutations\nfunction registerRunningReactionForOperation(operation) {\n  if (runningReaction) {\n    debugOperation(runningReaction, operation);\n    registerReactionForOperation(runningReaction, operation);\n  }\n}\n\nfunction queueReactionsForOperation(operation) {\n  // iterate and queue every reaction, which is triggered by obj.key mutation\n  getReactionsForOperation(operation).forEach(queueReaction, operation);\n}\n\nfunction queueReaction(reaction) {\n  debugOperation(reaction, this);\n  // queue the reaction for later execution or run it immediately\n  if (typeof reaction.scheduler === 'function') {\n    reaction.scheduler(reaction);\n  } else if (typeof reaction.scheduler === 'object') {\n    reaction.scheduler.add(reaction);\n  } else {\n    reaction();\n  }\n}\n\nfunction debugOperation(reaction, operation) {\n  if (reaction.debugger && !isDebugging) {\n    try {\n      isDebugging = true;\n      reaction.debugger(operation);\n    } finally {\n      isDebugging = false;\n    }\n  }\n}\n\nfunction hasRunningReaction() {\n  return runningReaction !== undefined;\n}\n\nvar IS_REACTION = Symbol('is reaction');\n\nfunction observe(fn, options) {\n  if ( options === void 0 ) options = {};\n\n  // wrap the passed function in a reaction, if it is not already one\n  var reaction = fn[IS_REACTION] ? fn : function reaction() {\n    return runAsReaction(reaction, fn, this, arguments);\n  };\n  // save the scheduler and debugger on the reaction\n  reaction.scheduler = options.scheduler;\n  reaction.debugger = options.debugger;\n  // save the fact that this is a reaction\n  reaction[IS_REACTION] = true;\n  // run the reaction once if it is not a lazy one\n  if (!options.lazy) {\n    reaction();\n  }\n  return reaction;\n}\n\nfunction unobserve(reaction) {\n  // do nothing, if the reaction is already unobserved\n  if (!reaction.unobserved) {\n    // indicate that the reaction should not be triggered any more\n    reaction.unobserved = true;\n    // release (obj -> key -> reaction) connections\n    releaseReaction(reaction);\n  }\n  // unschedule the reaction, if it is scheduled\n  if (typeof reaction.scheduler === 'object') {\n    reaction.scheduler.delete(reaction);\n  }\n}\n\nvar proxyToRaw = new WeakMap();\nvar rawToProxy = new WeakMap();\n\nvar getPrototypeOf = Object.getPrototypeOf;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar instrumentations = {\n  has: function has(key) {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, key: key, type: 'has' });\n    return proto.has.apply(target, arguments);\n  },\n  get: function get(key) {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, key: key, type: 'get' });\n    return proto.get.apply(target, arguments);\n  },\n  add: function add(key) {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    // forward the operation before queueing reactions\n    var result = proto.add.apply(target, arguments);\n    if (!hadKey) {\n      queueReactionsForOperation({ target: target, key: key, value: key, type: 'add' });\n    }\n    return result;\n  },\n  set: function set(key, value) {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    var oldValue = proto.get.call(target, key);\n    // forward the operation before queueing reactions\n    var result = proto.set.apply(target, arguments);\n    if (!hadKey) {\n      queueReactionsForOperation({ target: target, key: key, value: value, type: 'add' });\n    } else if (value !== oldValue) {\n      queueReactionsForOperation({ target: target, key: key, value: value, oldValue: oldValue, type: 'set' });\n    }\n    return result;\n  },\n  delete: function delete$1(key) {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    var oldValue = proto.get ? proto.get.call(target, key) : undefined;\n    // forward the operation before queueing reactions\n    var result = proto.delete.apply(target, arguments);\n    if (hadKey) {\n      queueReactionsForOperation({ target: target, key: key, oldValue: oldValue, type: 'delete' });\n    }\n    return result;\n  },\n  clear: function clear() {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    var hadItems = target.size !== 0;\n    var oldTarget = target instanceof Map ? new Map(target) : new Set(target);\n    // forward the operation before queueing reactions\n    var result = proto.clear.apply(target, arguments);\n    if (hadItems) {\n      queueReactionsForOperation({ target: target, oldTarget: oldTarget, type: 'clear' });\n    }\n    return result;\n  },\n  forEach: function forEach() {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return proto.forEach.apply(target, arguments);\n  },\n  keys: function keys() {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return proto.keys.apply(target, arguments);\n  },\n  values: function values() {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return proto.values.apply(target, arguments);\n  },\n  entries: function entries() {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return proto.entries.apply(target, arguments);\n  },\n  get size() {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return Reflect.get(proto, 'size', target);\n  }\n};\ninstrumentations[Symbol.iterator] = function () {\n    var target = proxyToRaw.get(this);\n    var proto = getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return proto[Symbol.iterator].apply(target, arguments);\n  };\n\nvar collectionHandlers = {\n  get: function get(target, key, receiver) {\n    // instrument methods and property accessors to be reactive\n    target = hasOwnProperty.call(instrumentations, key) ? instrumentations : target;\n    return Reflect.get(target, key, receiver);\n  }\n};\n\n// eslint-disable-next-line\nvar globalObj = Function(\"return this\")();\n\n// built-in object can not be wrapped by Proxies\n// their methods expect the object instance as the 'this' instead of the Proxy wrapper\n// complex objects are wrapped with a Proxy of instrumented methods\n// which switch the proxy to the raw object and to add reactive wiring\nvar handlers = new Map([[Map, collectionHandlers], [Set, collectionHandlers], [WeakMap, collectionHandlers], [WeakSet, collectionHandlers], [Object, false], [Array, false], [Int8Array, false], [Uint8Array, false], [Uint8ClampedArray, false], [Int16Array, false], [Uint16Array, false], [Int32Array, false], [Uint32Array, false], [Float32Array, false], [Float64Array, false]]);\n\nfunction shouldInstrument(ref) {\n  var constructor = ref.constructor;\n\n  var isBuiltIn = typeof constructor === 'function' && constructor.name in globalObj && globalObj[constructor.name] === constructor;\n  return !isBuiltIn || handlers.has(constructor);\n}\n\nfunction getHandlers(obj) {\n  return handlers.get(obj.constructor);\n}\n\nvar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n// intercept get operations on observables to know which reaction uses their properties\nfunction get(target, key, receiver) {\n  var result = Reflect.get(target, key, receiver);\n  // do not register (observable.prop -> reaction) pairs for these cases\n  if (typeof key === 'symbol' || typeof result === 'function') {\n    return result;\n  }\n  // register and save (observable.prop -> runningReaction)\n  registerRunningReactionForOperation({ target: target, key: key, receiver: receiver, type: 'get' });\n  // if we are inside a reaction and observable.prop is an object wrap it in an observable too\n  // this is needed to intercept property access on that object too (dynamic observable tree)\n  var observableResult = rawToProxy.get(result);\n  if (hasRunningReaction() && typeof result === 'object' && result !== null) {\n    if (observableResult) {\n      return observableResult;\n    }\n    // do not violate the none-configurable none-writable prop get handler invariant\n    // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError\n    var descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n    if (!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) {\n      return observable(result);\n    }\n  }\n  // otherwise return the observable wrapper if it is already created and cached or the raw object\n  return observableResult || result;\n}\n\nfunction has(target, key) {\n  var result = Reflect.has(target, key);\n  // do not register (observable.prop -> reaction) pairs for these cases\n  if (typeof key === 'symbol') {\n    return result;\n  }\n  // register and save (observable.prop -> runningReaction)\n  registerRunningReactionForOperation({ target: target, key: key, type: 'has' });\n  return result;\n}\n\nfunction ownKeys(target) {\n  registerRunningReactionForOperation({ target: target, type: 'iterate' });\n  return Reflect.ownKeys(target);\n}\n\n// intercept set operations on observables to know when to trigger reactions\nfunction set(target, key, value, receiver) {\n  // make sure to do not pollute the raw object with observables\n  if (typeof value === 'object' && value !== null) {\n    value = proxyToRaw.get(value) || value;\n  }\n  // save if the object had a descriptor for this key\n  var hadKey = hasOwnProperty$1.call(target, key);\n  // save if the value changed because of this set operation\n  var oldValue = target[key];\n  // execute the set operation before running any reaction\n  var result = Reflect.set(target, key, value, receiver);\n  // emit a warning and do not queue anything when another reaction is queued\n  // from an already running reaction\n  if (hasRunningReaction()) {\n    console.error((\"Mutating observables in reactions is forbidden. You set \" + key + \" to \" + value + \".\"));\n    return result;\n  }\n  // do not queue reactions if it is a symbol keyed property\n  // or the target of the operation is not the raw receiver\n  // (possible because of prototypal inheritance)\n  if (typeof key === 'symbol' || target !== proxyToRaw.get(receiver)) {\n    return result;\n  }\n\n  // queue a reaction if it's a new property or its value changed\n  if (!hadKey) {\n    queueReactionsForOperation({ target: target, key: key, value: value, receiver: receiver, type: 'add' });\n  } else if (value !== oldValue) {\n    queueReactionsForOperation({\n      target: target,\n      key: key,\n      value: value,\n      oldValue: oldValue,\n      receiver: receiver,\n      type: 'set'\n    });\n  }\n  return result;\n}\n\nfunction deleteProperty(target, key) {\n  // save if the object had the key\n  var hadKey = hasOwnProperty$1.call(target, key);\n  var oldValue = target[key];\n  // execute the delete operation before running any reaction\n  var result = Reflect.deleteProperty(target, key);\n  // only queue reactions for non symbol keyed property delete which resulted in an actual change\n  if (typeof key !== 'symbol' && hadKey) {\n    queueReactionsForOperation({ target: target, key: key, oldValue: oldValue, type: 'delete' });\n  }\n  return result;\n}\n\nvar baseHandlers = { get: get, has: has, ownKeys: ownKeys, set: set, deleteProperty: deleteProperty };\n\nfunction observable(obj) {\n  if ( obj === void 0 ) obj = {};\n\n  // if it is already an observable or it should not be wrapped, return it\n  if (proxyToRaw.has(obj) || !shouldInstrument(obj)) {\n    return obj;\n  }\n  // if it already has a cached observable wrapper, return it\n  // otherwise create a new observable\n  return rawToProxy.get(obj) || createObservable(obj);\n}\n\nfunction createObservable(obj) {\n  // if it is a complex built-in object or a normal object, wrap it\n  var handlers = getHandlers(obj) || baseHandlers;\n  var observable = new Proxy(obj, handlers);\n  // save these to switch between the raw object and the wrapped object with ease later\n  rawToProxy.set(obj, observable);\n  proxyToRaw.set(observable, obj);\n  // init basic data structures to save and cleanup later (observable.prop -> reaction) connections\n  storeObservable(obj);\n  return observable;\n}\n\nfunction isObservable(obj) {\n  return proxyToRaw.has(obj);\n}\n\nfunction raw(obj) {\n  return proxyToRaw.get(obj) || obj;\n}\n\nexports.observe = observe;\nexports.unobserve = unobserve;\nexports.observable = observable;\nexports.isObservable = isObservable;\nexports.raw = raw;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@nx-js/observer-util/dist/cjs.es5.js\n// module id = 24\n// module chunks = 114276838955818 120173200258306 201563372448855 213130420965792","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar react = require('react');\nvar observerUtil = require('@nx-js/observer-util');\n\nfunction view(Comp, ref) {\n  if ( ref === void 0 ) ref = {};\n  var rawDevtool = ref.devtool;\n\n  var isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent);\n  var BaseComp = isStatelessComp ? react.Component : Comp;\n\n  var devtool = rawDevtool ? function (operation) { return rawDevtool(Object.assign({ Component: Comp }, operation)); } : undefined;\n\n  // return a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount\n  // it decides when to run the new reactive methods and when to proxy to the original methods\n  var ReactiveHOC = (function (BaseComp) {\n    function ReactiveHOC(props, context) {\n      var this$1 = this;\n\n      BaseComp.call(this, props, context);\n\n      // create a reactive render for the component\n      // run a dummy setState to schedule a new reactive render, avoid forceUpdate\n      this.render = observerUtil.observe(this.render, {\n        scheduler: function () { return this$1.setState({}); },\n        debugger: devtool,\n        lazy: true\n      });\n    }\n\n    if ( BaseComp ) ReactiveHOC.__proto__ = BaseComp;\n    ReactiveHOC.prototype = Object.create( BaseComp && BaseComp.prototype );\n    ReactiveHOC.prototype.constructor = ReactiveHOC;\n\n    ReactiveHOC.prototype.render = function render () {\n      return isStatelessComp ? Comp(this.props, this.context) : BaseComp.prototype.render.call(this);\n    };\n\n    // react should trigger updates on prop changes, while easyState handles store changes\n    ReactiveHOC.prototype.shouldComponentUpdate = function shouldComponentUpdate (nextProps, nextState) {\n      var ref = this;\n      var props = ref.props;\n      var state = ref.state;\n\n      // respect the case when user prohibits updates\n      if (BaseComp.prototype.shouldComponentUpdate && !BaseComp.prototype.shouldComponentUpdate.call(this, nextProps, nextState)) {\n        devtool && devtool({ type: 'render', renderType: 'blocked' });\n        return false;\n      }\n\n      // return true if it is a reactive render or state changes\n      if (state !== nextState) {\n        devtool && devtool({ type: 'render', renderType: 'reactive' });\n        return true;\n      }\n\n      // the component should update if any of its props shallowly changed value\n      var keys = Object.keys(props);\n      var nextKeys = Object.keys(nextProps);\n      if (nextKeys.length !== keys.length || nextKeys.some(function (key) { return props[key] !== nextProps[key]; })) {\n        devtool && devtool({\n          type: 'render',\n          renderType: 'normal',\n          props: nextProps,\n          oldProps: props\n        });\n        return true;\n      }\n      return false;\n    };\n\n    ReactiveHOC.prototype.componentWillUnmount = function componentWillUnmount () {\n      // call user defined componentWillUnmount\n      if (BaseComp.prototype.componentWillUnmount) {\n        BaseComp.prototype.componentWillUnmount.call(this);\n      }\n      // clean up memory used by Easy State\n      observerUtil.unobserve(this.render);\n    };\n\n    return ReactiveHOC;\n  }(BaseComp));\n\n  ReactiveHOC.displayName = Comp.displayName || Comp.name;\n  // these are inherited by class components,\n  // but have to be copied for function components\n  if (isStatelessComp) {\n    ReactiveHOC.contextTypes = Comp.contextTypes;\n    ReactiveHOC.childContextTypes = Comp.childContextTypes;\n    ReactiveHOC.propTypes = Comp.propTypes;\n    ReactiveHOC.defaultProps = Comp.defaultProps;\n  }\n\n  return ReactiveHOC;\n}\n\nexports.store = observerUtil.observable;\nexports.view = view;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/react-easy-state/dist/cjs.es5.js\n// module id = 13\n// module chunks = 114276838955818 120173200258306 201563372448855 213130420965792","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ThemeSwitch = function (_Component) {\n  _inherits(ThemeSwitch, _Component);\n\n  function ThemeSwitch(props) {\n    _classCallCheck(this, ThemeSwitch);\n\n    var _this = _possibleConstructorReturn(this, (ThemeSwitch.__proto__ || Object.getPrototypeOf(ThemeSwitch)).call(this, props));\n\n    _this.store = typeof localStorage === 'undefined' ? null : localStorage;\n\n    _this.css = '\\n      html { filter: invert(100%); background: #fefefe; }\\n      * { background-color: inherit }\\n    ';\n\n    if (_this.props.preserveRasters) {\n      _this.css += 'img:not([src*=\".svg\"]), video, [style*=\"url(\"] { filter: invert(100%) }';\n    }\n\n    _this.state = {\n      active: false,\n      supported: true\n    };\n\n    _this.toggle = _this.toggle.bind(_this);\n    return _this;\n  }\n\n  _createClass(ThemeSwitch, [{\n    key: 'invertSupported',\n    value: function invertSupported(property, value) {\n      var prop = property + ':',\n          el = document.createElement('test'),\n          mStyle = el.style;\n      el.style.cssText = prop + value;\n      return mStyle[property];\n    }\n  }, {\n    key: 'toggle',\n    value: function toggle() {\n      this.setState({\n        active: !this.state.active\n      });\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (this.store) {\n        this.setState({\n          supported: this.invertSupported('filter', 'invert(100%)'),\n          active: this.store.getItem('ThemeSwitch') || false\n        });\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      if (this.store) {\n        this.store.setItem('ThemeSwitch', this.state.active);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      if (!this.state.supported) {\n        return null;\n      }\n\n      return _react2.default.createElement(\n        'div',\n        null,\n        _react2.default.createElement(\n          'button',\n          { 'aria-pressed': this.state.active, onClick: this.toggle },\n          'inverted theme: ',\n          _react2.default.createElement(\n            'span',\n            { 'aria-hidden': 'true' },\n            this.state.active ? 'on' : 'off'\n          )\n        ),\n        _react2.default.createElement(\n          'style',\n          { media: this.state.active ? 'screen' : 'none' },\n          this.state.active ? this.css.trim() : this.css\n        )\n      );\n    }\n  }]);\n\n  return ThemeSwitch;\n}(_react.Component);\n\nThemeSwitch.defaultProps = { preserveRasters: 'true' };\n\nexports.default = ThemeSwitch;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/react-theme-switch/build/index.js\n// module id = 137\n// module chunks = 114276838955818 120173200258306","// Default values\nexport default {\n  breakpoints: [32, 48, 64, 80],\n  space: [0, 4, 8, 16, 32, 64, 128],\n  fontSizes: [12, 14, 15, 20, 24, 32, 48, 64, 72, 96],\n  weights: [400, 700],\n  colors: {\n    purplegatsby: '#744c9e',\n    black: \"#303030\",\n    blacktotal: '#000',\n    lightGrey: \"#E9E7E7\",\n    grey: \"#bbb\",\n    gold: \"#cdc1a4\",\n    aqua:  '#7FDBFF',\n    blue:  '#0074D9',\n    navy:  '#001F3F',\n    teal:  '#39CCCC',\n    tealdarker:  '#2ca9a9',  \n    green: '#2ECC40',\n    olive: '#3D9970',\n    lime:  '#01FF70',\n    yellow:  '#FFDC00',\n    orange:  '#FF851B',\n    red:     '#FF4136',\n    fuchsia: '#F012BE',\n    purple:  '#B10DC9',\n    maroon:  '#85144B',\n    white:  '#FFFFFF',\n    silver: '#DDDDDD',\n    gray:   '#AAAAAA',\n    primary: \"#F46965\",\n    secondary: \"#cdc1a4\",\n    secondaryLight: \"#e4ddcd\",\n    secondaryLightest: \"#f5f2ed\",\n    secondaryDark: \"#d1ba85\",\n    light: \"#fff\",\n    offLight: \"#E2E6EA\",\n  },\n  shadows: {\n    basic: \"0 1px 3px rgba(50,50,93,.06)\"\n  },\n  bg: \"#aea\",\n  radius: 4,\n  font: '\"Roboto\", sans-serif',\n  headerFont: '\"Anonymous Pro\",\"Poppins\",\"Helvetica Neue\", \"Segoe UI\",\"Helvetica\", \"Arial\", \"sans-serif\"',\n  monospace: '\"SF Mono\", \"Roboto Mono\", Menlo, monospace',\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/data/rebassTheme.jsx","import { store } from 'react-easy-state'\nimport rebassTheme from './rebassTheme';\n\nexport const themeMode = store(\n  {\n    darkMode: true,\n  }\n)\n\n\n\nexport const themeVariables = store({\n         primaryColor: 'white',\n         secondaryColor: 'lightGrey',\n         additionalColor: 'tealdarker',\n         tagBadgeBgColor: 'tealdarker',\n         fontColor: 'black',\n         fontAdditionalColor: 'tealdarker',\n         headerFont:\n           '\"Poppins\",\"Helvetica Neue\", \"Segoe UI\",\"Helvetica\", \"Arial\", \"sans-serif\"',\n         bodyFont: '\"Roboto\", sans-serif',\n         AdditionalFont: '\"SF Mono\", \"Roboto Mono\", Menlo, monospace',\n       })\n\nexport const lightMode = store(\n  {\n    primaryColor: 'black',\n    secondaryColor: 'white',\n    additionalColor: 'teal',\n    fontColor: 'black',\n    fontAdditionalColor: 'green',\n  }\n)\n\n\nexport const darkMode = store({\n  primaryColor: 'black',\n  secondaryColor: 'white',\n  additionalColor: 'teal',\n  fontColor: 'black',\n  fontAdditionalColor: 'green',\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/data/themeStore.jsx","import React, { Component } from 'react'\nimport Helmet from 'react-helmet'\nimport { Container, Switch } from 'rebass'\nimport { FadeIn } from 'animate-components'\nimport { themeMode, themeVariables } from '../data/themeStore'\nimport { view } from 'react-easy-state'\nimport ThemeSwitch from 'react-theme-switch'\n\nclass AboutPage extends Component {\n  render(view) {\n    return <Container pt={4} pb={6}>\n        <FadeIn>\n        </FadeIn>\n      </Container>\n  }\n}\n\nexport default AboutPage\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/sobre.jsx"],"sourceRoot":""}